use log::{debug, info};

mod generator;
use crate::parser::{ASTClass, ASTInstruction, ASTMethod, AccessFlags, ASTI};
pub use generator::Generator;

static LIBRUNTIME_IMPORT_PATH: &str = r#""../libruntime/libruntime.h""#;
static AAR_HEADER: &str = "//* Generated by the AAR generator";

#[derive(Debug)]
pub enum GenerationError {}

pub fn generate_boilerplate(g: &mut Generator) {
  g.h.h_writeln(AAR_HEADER);
  g.h.h_writeln("#ifndef APP_H");
  g.h.h_writeln("#define APP_H");
  g.h.h_writeln("");
  g.h.h_writeln("#include <stdint.h>");
  g.h.h_writeln("#include <stdio.h>");
  g.h
    .h_writeln(&format!("#include {}", LIBRUNTIME_IMPORT_PATH));
  g.h.h_writeln("");
  g.h.h_writeln("");
  g.h.f_writeln("#endif");

  g.c.h_writeln(AAR_HEADER);
  g.c.h_writeln(r#"#include "./out.h""#);
  g.c.h_writeln("");
}

fn type_to_c(t: &dex::jtype::Type, _d: &dex::Dex<memmap::Mmap>) -> String {
  if t.is_class() {
    match &t.type_descriptor().to_string() as &str {
      _ => format!("struct CLASS_{}", t.id()),
    }
  } else if t.is_array() {
    format!(
      "/* ARRAY (T: {}) {:?}*/ int32_t",
      t.id(),
      t.array_dimensions()
    )
  } else {
    let type_str: &str = &t.type_descriptor().to_string();
    type_str_to_c(type_str)
  }
}

fn type_str_to_c(type_str: &str) -> String {
  match type_str {
    "V" => format!("void"),
    "Z" => format!("boolean"),
    "B" => format!("byte"),
    "S" => format!("short"),
    "C" => format!("char"),
    "I" => format!("int32_t"),
    "J" => format!("long"),
    "F" => format!("float"),
    "D" => format!("double"),
    "L" => format!("/* not_implementet L*/"),
    ty => unimplemented!("Type: {}", ty),
  }
}

pub fn generate_definitions(g: &mut Generator, d: &dex::Dex<memmap::Mmap>) {
  for t in d.types() {
    let t = t.expect("Could not read type");
    let literal_type = type_to_c(&t, d);
    g.h.h_writeln(&format!(
      "#define TYPE_{} {} // {}",
      t.id(),
      literal_type,
      t.type_descriptor()
    ));
  }
  g.h.h_writeln("");
}

pub fn generate_class(
  g: &mut Generator,
  c: &mut ASTClass,
  d: &dex::Dex<memmap::Mmap>,
) -> Result<(), GenerationError> {
  let c_name = format!("CLASS_{}", c.class_id);

  g.h.writeln(&format!("// Class {:#010x?}", c.class_id));
  g.h.writeln(&format!("struct {} {{", c_name));
  g.h.writeln(&format!("}}; // END class {}", c_name));

  for m in &mut c.methods {
    generate_method(g, m, &c_name, d)?;
  }

  g.h.writeln("");
  Ok(())
}

fn friendlyize_name(s: &str) -> String {
  s.replace("<init>", "__constructor")
    .replace("<", "_")
    .replace(">", "_")
}

fn generate_params(params: &Vec<String>, reg_0: usize) -> String {
  let mut out = Vec::new();
  for (i, p) in params.iter().enumerate() {
    out.push(format!("{} p{}", p, reg_0 + i));
  }
  out.join(", ")
}

fn generate_method(
  g: &mut Generator,
  m: &mut ASTMethod,
  c_name: &str,
  d: &dex::Dex<memmap::Mmap>,
) -> Result<(), GenerationError> {
  g.h.writeln(&format!("// Method: {:?}", m.name));
  let mut params = Vec::new();
  g.h
    .writeln(&format!("// Method Params(excl this): {:?}", m.params));

  if m.access_flags.contains(AccessFlags::ABSTRACT) {
    //? Is skipping abstract CLASSES possible? Or do we need to be able to copy the contents of the non-abstract class's methods and properties?
    // We should be able to just skip any abstract methods, according to the java documentation:
    // https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html#PageContent:~:text=When%20an%20abstract%20class%20is%20subclassed%2C,subclass%20must%20also%20be%20declared%20abstract.
    debug!("Skipping abstract method: {}", m.name);
    return Ok(());
  }

  let params_reg_0 = if m.access_flags.contains(AccessFlags::STATIC) {
    g.h.writeln("// Static");
    m.registers - m.params.len()
  } else {
    params.push(format!("struct {}*", c_name));
    m.registers - m.params.len() - 1
  };

  for p in &m.params {
    params.push(format!("TYPE_{}", p.id()));
  }

  g.h.writeln(&format!(
    "TYPE_{} {}__{} ({});",
    m.return_type.id(),
    c_name,
    friendlyize_name(&m.name),
    generate_params(&params, params_reg_0)
  ));
  g.c.writeln(&format!(
    "TYPE_{} {}__{} ({}) {{",
    m.return_type.id(),
    c_name,
    friendlyize_name(&m.name),
    generate_params(&params, params_reg_0)
  ));
  g.c.indentation_incr();

  g.c.writeln(&format!("void* pregs = hashset_create();"));
  g.c.writeln(&format!("size_t alloc_idx = 0;"));
  g.c.writeln(&format!("void* allocs[{}];", 10));

  g.c.writeln(&format!("int32_t v[{}];", m.registers));

  for v in m.registers - m.params.len()..m.registers {
    g.c.writeln(&format!("v[{ri}] = p{ri};", ri = v));
  }

  for (i, ins) in m.body.iter().enumerate() {
    let idx = m.targets.iter().position(|&x| x == i);
    if let Some(idx) = idx {
      g.c.indentation_decr();
      g.c.writeln(&format!("TARGET_{}:", idx));
      g.c.indentation_incr();
    }
    generate_instruction(g, ins, d)?;
  }
  g.c.indentation_decr();
  g.c.writeln("}");
  g.c.writeln("");
  Ok(())
}

fn do_free<'a>() -> String {
  format!("{{ /* FREE ALL */ pregs_free_all(pregs, *v, *allocs); hashset_destroy(pregs); }}")
}

fn clear_v(g: &mut Generator, register: usize) {
  //todo Call destructor if instance?
  g.c.writeln(&format!(
    "if (hashset_is_member(pregs, {v})) {{ free(allocs[v[{v}]]); hashset_remove(pregs, {v}); }} // Free {v} if pointer",
    v = register
  ));
}

fn generate_instruction(
  g: &mut Generator,
  asti_instruction: &ASTI,
  _d: &dex::Dex<memmap::Mmap>,
) -> Result<(), GenerationError> {
  match asti_instruction {
    ASTI::Instruction(instruction) => match instruction {
      ASTInstruction::Nop(_) => {}
      ASTInstruction::Move(a) => {
        let dr: u8 = a.0.into();
        clear_v(g, dr as usize);
        g.c.writeln(&format!("v[{}] = v[{}]; // Move", a.0, a.1));
      }
      ASTInstruction::ReturnVoid(_) => {
        g.c.writeln(&do_free());
        g.c.writeln(&format!("return; // void"))
      }
      ASTInstruction::Return(a) => {
        g.c.writeln(&do_free());
        g.c
          .writeln(&format!("return v[{}]; // return {}", a.0, a.0));
      }
      // ASTInstruction::ReturnObject(_a) => {
      //   // ! Do not free the returning variable
      //   unimplemented!();
      // }
      ASTInstruction::Const4(a) => {
        let dr: u8 = a.0.into();
        clear_v(g, dr as usize);
        g.c.writeln(&format!("v[{}] = {}; // Const4", a.0, a.1));
      }
      ASTInstruction::Const16(a) => {
        clear_v(g, a.0 as usize);
        g.c
          .writeln(&format!("v[{}] = {}; // Const16", a.0, a.1 as i32));
      }
      ASTInstruction::NewInstance(a) => {
        // let m = d.get_method_item(a.1 as u64).unwrap();
        // let idx = m.class_idx();
        // let name = d.get_string(m.name_idx()).unwrap().to_string();
        // let e = d.get_proto_item(m.proto_idx() as u64).unwrap();

        g.c.writeln("{ // NewInstance");
        g.c.indentation_incr();
        clear_v(g, a.0 as usize);
        g.c.writeln(&format!(
          "void* a = malloc(sizeof(TYPE_{t_idx}));",
          t_idx = a.1,
        ));
        g.c.writeln(&format!("allocs[alloc_idx] = a;"));
        g.c.writeln(&format!("v[{v}] = alloc_idx;", v = a.0));
        g.c.writeln(&format!("alloc_idx += 1;"));
        g.c.indentation_decr();
        g.c.writeln("} // END NewInstance");
      }
      ASTInstruction::NewArray(a) => {
        g.c.writeln("{ // NewArray");
        g.c.indentation_incr();
        let dr: u8 = a.0.into();
        clear_v(g, dr as usize);
        g.c.writeln(&format!(
          "void* a = calloc(v[{}], sizeof(TYPE_{}));",
          a.1, a.2
        ));
        g.c.writeln(&format!("if (a==NULL) exit(1);"));
        g.c.writeln(&format!("allocs[alloc_idx] = a;"));
        g.c.writeln(&format!("v[{}] = alloc_idx;", a.0));
        g.c.writeln(&format!("hashset_add(pregs, {});", a.0));
        g.c.writeln(&format!("alloc_idx += 1;"));
        g.c.indentation_decr();
        g.c.writeln("} // END NewArray");
      }
      ASTInstruction::FillArrayData(a) => {
        g.c.writeln("{ // FillArrayData");
        g.c.indentation_incr();
        g.c.writeln(&format!("uint8_t* a = allocs[v[{}]];", a.0));
        for (i, d) in a.1.iter().enumerate() {
          g.c
            .writeln(&format!("a[{i}] = {d}; // d: {d}, i: {i}", d = d, i = i,));
        }
        g.c.indentation_decr();
        g.c.writeln("} // END FillArrayData");
      }
      ASTInstruction::Aget(a) => {
        g.c.writeln(&format!(
          "if(hashset_is_member(pregs, {source})) {{ // Aget",
          source = a.1
        ));
        g.c.indentation_incr();
        g.c.writeln(&format!(
          "int32_t a = ((int32_t*)allocs[v[{source}]]) [v[{idx}]]; // In case v[{source}] is the source register",
          source = a.1,
          idx = a.2,
        ));
        if a.0 == a.1 {
          clear_v(g, a.1 as usize);
        }
        g.c.writeln(&format!("v[{dest}] = a;", dest = a.0,));
        g.c.indentation_decr();
        g.c.writeln(&format!("}} else abort(); // END Aget"));
      }
      ASTInstruction::Aput(a) => {
        g.c.writeln(&format!(
          "if(hashset_is_member(pregs, {source})) {{ // Aput",
          source = a.1
        ));
        g.c.indentation_incr();

        //? What if element is an instance?
        g.c.writeln(&format!(
          "((int32_t*)allocs[v[{arr}]]) [v[{idx}]] = v[{source}];",
          source = a.0,
          arr = a.1,
          idx = a.2
        ));

        g.c.indentation_decr();
        g.c.writeln(&format!("}} else abort(); // END Aput"));
      }
      ASTInstruction::AddIntLit8(a) => {
        let dr: u8 = a.0.into();
        clear_v(g, dr as usize);
        g.c
          .writeln(&format!("v[{}] = v[{}] + {}; // AddIntLit8", a.0, a.1, a.2));
      }
      ASTInstruction::AddInt2addr(a) => {
        let dr: u8 = a.0.into();
        clear_v(g, dr as usize);
        g.c.writeln(&format!(
          "v[{first}] = v[{first}] + v[{second}]; // AddInt2addr",
          first = a.0,
          second = a.1,
        ));
      }
      i => g.c.writeln(&format!("//todo {:?}", i)),
    },
    ASTI::Target(t) => {
      g.c.indentation_decr();
      g.c.writeln(&format!("TARGET_{}:", t));
      g.c.indentation_incr();
    }
    ASTI::Goto(t) => g.c.writeln(&format!("goto TARGET_{};", t)),
    ASTI::PackedSwitch(register, initial, targets) => {
      g.c
        .writeln(&format!("switch (v[{}]) {{ // PackedSwitch", register));
      g.c.indentation_incr();
      for (i, t) in targets.iter().enumerate() {
        g.c
          .writeln(&format!("case {}+{}: goto TARGET_{};", initial, i, t));
      }
      g.c.indentation_decr();
      g.c.writeln(&format!("}}"));
    }
    ASTI::SparseSwitch(register, targets) => {
      g.c
        .writeln(&format!("switch (v[{:?}]) {{ // SparseSwitch", register));
      g.c.indentation_incr();
      for (key, target) in targets.iter() {
        g.c
          .writeln(&format!("case {}: goto TARGET_{};", key, target));
      }
      g.c.indentation_decr();
      g.c.writeln(&format!("}}"));
    }
    ASTI::IfEq(a, b, t) => g.c.writeln(&format!(
      "if(IS_EQUAL(v[{}], v[{}])) goto TARGET_{};",
      a, b, t
    )),
    ASTI::IfNe(a, b, t) => g
      .c
      .writeln(&format!("if(NOT_EQUAL(v{}, v{})) goto TARGET_{};", a, b, t)),
    ASTI::MoveResult(res_idx, dest) => {
      clear_v(g, *dest as usize);
      g.c.writeln(&format!(
        "v[{dest}] = res_{res_idx}; // MoveResult",
        dest = dest,
        res_idx = res_idx
      ));
    }
    ASTI::InvokeVirtual((res_idx, shorty, class_id, name, param_count, param_regs)) => {
      let res_var = gen_res_var(&shorty, res_idx);
      let params = gen_params(param_count, param_regs);

      g.c.writeln(&format!(
        "{res_var}CLASS_{class_id}__{name}({params}); // InvokeVirtual {name} {p_count}: {param_regs:?}",
        res_var = res_var,
        class_id = class_id,
        name =  friendlyize_name(&name),
        params = params.join(", "),
        p_count = param_count,
        param_regs = param_regs,
      ));
    }
    ASTI::InvokeSuper((res_idx, shorty, class_id, name, param_count, param_regs)) => {
      let res_var = gen_res_var(&shorty, &res_idx);
      let params = gen_params(param_count, param_regs);

      g.c.writeln(&format!(
        "{res_var}CLASS_{class_id}__{name}({params}); // InvokeSuper {name} {p_count}: {param_regs:?}",
        res_var = res_var,
        class_id = class_id,
        name = friendlyize_name(&name),
        params = params.join(", "),
        p_count = param_count,
        param_regs = param_regs,
      ));
    }
    ASTI::InvokeDirect((res_idx, shorty, class_id, name, param_count, param_regs)) => {
      let res_var = gen_res_var(&shorty, &res_idx);
      let params = gen_params(param_count, param_regs);

      g.c.writeln(&format!(
        "{res_var}CLASS_{class_id}__{name}({params}); // InvokeDirect {name} {p_count}: {param_regs:?}",
        res_var = res_var,
        class_id = class_id,
        name = friendlyize_name(&name),
        params = params.join(", "),
        p_count = param_count,
        param_regs = param_regs,
      ));
    }
    ASTI::InvokeStatic((res_idx, shorty, class_id, name, param_count, param_regs)) => {
      let res_var = gen_res_var(&shorty, &res_idx);
      // let params = gen_params(param_count, param_regs);

      let mut params = Vec::new();
      for i in 0..*param_count {
        params.push(format!("v[{:?}]", param_regs[i as usize]));
      }

      g.c.writeln(&format!(
        "{res_var}CLASS_{class_id}__{name}({params}); // InvokeStatic {name} {p_count}: {param_regs:?}",
        res_var = res_var,
        class_id = class_id,
        name = friendlyize_name(&name),
        params = params.join(", "),
        p_count = param_count,
        param_regs = param_regs,
      ));
    }
  }

  Ok(())
}

fn gen_res_var(shorty: &str, res_idx: &usize) -> String {
  let r_type = &shorty[0..1];
  if r_type != "V" {
    let t = type_str_to_c(r_type);
    format!("{t} res_{res_idx} = ", t = t, res_idx = res_idx)
  } else {
    format!("")
  }
}

fn gen_params(param_count: &u8, param_regs: &[u8; 5]) -> Vec<String> {
  //? Should the first parameter always be treated as an instance/pointer? - no (static methods)
  let mut params = Vec::new();
  params.push(format!("allocs[v[{param_1}]]", param_1 = param_regs[0]));

  for i in 0..*param_count - 1 {
    params.push(format!("v[{:?}]", param_regs[i as usize + 1]));
  }

  return params;
}
