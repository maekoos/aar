#!/usr/bin/python3

"""
Generate ../generated.rs
-------------------------

TODO: Use build.rs instead?
"""

import re


def is_comment(str):
    return str.lstrip().find("#") == 0


def is_format(str):
    return str.lstrip().find("format") == 0


def is_op(str):
    return str.lstrip().find("op") == 0


def parse_format(str):
    return str.strip().split("#", 1)[0].split()[1:]


class Op:
    def __init__(self, op_code, name, fo, hrr, it, flags):
        self.op_code = op_code
        self.name = name
        self.format = fo
        self.has_result_register = hrr  # (hrr == 'y' or hrr == True)
        self.index_type = it
        self.flags = flags

    def __str__(self):
        return 'Op({}, "{}", {}, {}, {}, {})'.format(
            self.op_code,
            self.name,
            self.format,
            self.has_result_register,
            self.index_type,
            self.flags,
        )


def parse_op(str):
    ln = str.strip().split()[1:]
    return Op(ln[0], ln[1], ln[2], ln[3] == "y", ln[4], ln[5].split("|"))


def parse_file(fp):
    formats = []
    ops = {}
    with open(fp) as f:
        ln = f.readline()
        while ln:
            while is_comment(ln):
                ln = f.readline()

            if is_format(ln):
                formats.extend(parse_format(ln))

            if is_op(ln):
                o = parse_op(ln)
                ops[int(o.op_code, 16)] = o

            ln = f.readline()

    return (formats, ops)


def generate_template():
    with open("template.rs") as f:
        return ["".join(f.readlines())]


def format_name_enum(name):
    result = "".join(elem.capitalize()
                     for elem in re.split(r"/|-|\+|\^", name))

    return result


def generate_pub_enum(ops, enum_name="ASTInstruction"):
    e = []

    for op in ops:
        # if op exists in exceptions...
        if ops[op].name == 'packed-switch':
            e.append(
                format_name_enum(ops[op].name) + "(IFPackedSwitch), // " +
                ops[op].format)
        elif ops[op].name == 'sparse-switch':
            e.append(
                format_name_enum(ops[op].name) + "(IFSparseSwitch), // " +
                ops[op].format)
        elif ops[op].name == 'fill-array-data':
            e.append(
                format_name_enum(ops[op].name) + "(IFFillArrayData), // " +
                ops[op].format)
        else:
            e.append(
                format_name_enum(ops[op].name) + "(IF" + ops[op].format +
                "), // " + ops[op].format)

    e = list(map(lambda x: "\t" + x, e))

    e.insert(0, "pub enum " + enum_name + "{")
    e.insert(0, "#[derive(Debug, Clone)]")
    e.append("}")

    return e


def generate_pub_parser_fn(ops, fn_name="parse_instruction"):
    fn = []

    fn.append("let op_code = q.incr()?;")

    fn.append("match op_code {")
    for n in range(0, 0xFF + 1):
        if not n in ops:
            fn.append("\t{} => unreachable!(),".format(hex(n)))
        else:
            if ops[n].name == 'packed-switch':
                fn.append(
                    "\t0x{} => Ok(ASTInstruction::{}(instr_format!({}, q))),".
                    format(ops[n].op_code, format_name_enum(ops[n].name),
                           'PackedSwitch'))
            elif ops[n].name == 'sparse-switch':
                fn.append(
                    "\t0x{} => Ok(ASTInstruction::{}(instr_format!({}, q))),".
                    format(ops[n].op_code, format_name_enum(ops[n].name),
                           'SparseSwitch'))
            elif ops[n].name == 'fill-array-data':
                fn.append(
                    "\t0x{} => Ok(ASTInstruction::{}(instr_format!({}, q))),".
                    format(ops[n].op_code, format_name_enum(ops[n].name),
                           'FillArrayData'))
            else:
                fn.append(
                    "\t0x{} => Ok(ASTInstruction::{}(instr_format!({}, q))),".
                    format(ops[n].op_code, format_name_enum(ops[n].name),
                           ops[n].format))

    fn.append("}")

    fn = list(map(lambda x: "\t" + x, fn))
    fn.insert(
        0,
        "pub fn " + fn_name +
        "(q: &mut InstructionQueue) -> Result<ASTInstruction, ParserError> {",
    )
    fn.append("}")
    return fn


def generate_length_fn(ops):
    fn = []
    for o in ops:
        op = ops[o]
        oplen = int(op.format[0])
        fn.append('ASTInstruction::' + format_name_enum(op.name) + '(_) => ' +
                  str(oplen) + ',')

    fn = list(map(lambda x: '\t\t' + x, fn))

    fn.insert(0, 'pub fn instruction_length(instr: &ASTInstruction) -> u8 {')
    fn.insert(1, '\tmatch instr {')
    fn.append('\t}')
    fn.append('}')
    return fn


def generate(formats, ops):
    f = []
    f.append("//! DO NOT EDIT THIS FILE (generated.rs)")
    f.append("//! IT HAS BEEN GENERATED BY dex-parser-gen/generate.py")
    f.append("\n")
    f.extend(generate_template())
    f.append("\n")
    f.extend(generate_pub_enum(ops))
    f.append("")
    f.extend(generate_pub_parser_fn(ops))
    f.append("")
    f.extend(generate_length_fn(ops))

    return "\n".join(f)


if __name__ == "__main__":
    (formats, ops) = parse_file("op-codes.txt")

    out = generate(formats, ops)
    with open("../generated.rs", "w") as f:
        f.write(out)

    print("Generated parser and wrote to generated.rs")
